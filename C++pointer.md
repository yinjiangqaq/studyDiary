## C++ 指针

C++学的内容其实是学内存，而不是学什么代码。举个例子 int a 这相当于开一个 4 字节的内存，并命名为 a

## 内存四区

- 代码区
- 全局区 (全局的常量和变量)
- 栈区 (系统自开辟，自动释放。栈区并不是很大)
- 堆区(动态开辟的内存，手动开辟和释放。很大)

## 地址

地址：把内存以单个字节为单位分开，每个字节进行编号，这个编号就是地址。(八位一字节，八位其实就是地址)

1. 编号是连续的
2. 唯一的
3. 取地址运算符：`&` 单目运算符的优先级只比` () [] .`低
4. 首地址： 是一段内存空间中第一个存储单元的地址。`a[5]`这个数组的首地址是第一个元素的地址，`a[5][5]`这个数组指向的是第一个一维数组`a[5]`的首地址

5. 指针变量：专门用来**存放地址的变量**。它的存在大小都是四个字节

**指针变量的定义**： `用一个数据类型+ \*+变量名`例如 `int *a`,这个指针变量存的是地址，int 表示指针指向的数据类型是整形，`\*`表明这个 a 是一个指针变量

**指针变量的赋值**：

```c++
int a=5//定义了一个a变量，赋值为5
int *p;//定义了一个p的指针变量
p=&a;//p的指针变量指向了a的地址。所以指针变量p存放的值是a的地址

//所以现在访问a的方式是：直接使用a这个变量，或者使用p指针变量指向的内存的值，`*p`这里的*是取值运算符

printf('%d',a);
printf('%d',*p);
```

**指针变量的运算**：只是做一些指针的偏移，也就是去访问地址旁边的一些内存

指针变量的加减：是以指针所指向的数据类型的空间单位进行偏移

```
char *p // char类型一个字节  p+1 偏移一个字节
int *p1 // int 类型 四个字节  p1+1 偏移四个字节
double *p2 //double类型 8个字节 p2+1 偏移八个字节
```

### 野指针

野指针就是不能明确指向的指针变量,也就是不知道地址的指针变量,也就是指向不明确。野指针是很危险的。需要给它赋值为空

```c++
int *p =NULL;
```

### 空指针

不指向任何实际对象或者函数的指针就是空指针

```
int *p=NULL;
```

野指针是没有被初始化的指针，所以，指针变量在创建的同时应当被初始化，要么将指针赋值为 NULL，要么让它指向合法的内存。

```
char* p = NULL;
char* str = (char*)malloc(1024);
```

## 一维数组与指针

定义一个一维数组，**数组名就是一维数组的首地址**，也就是`a[0]`这个元素的地址，也就是说 `数组名a = &a[0]`

```
int a[5]
a指向a[0]， a[0]int元素， a就是int*

printf('a=%d/n',a)//假设是地址1000，这里是a[0]的地址
printf('&a=%d/n',&a)//下面也是地址1000，但是这个是数组a的首地址，它的数据类型是 int(*)[5]，指向的是整个数组

printf('a+1=%d/n',a+1)//  1004  加了四个字节，因为类型是a[0]这个元素，单位是4个字节
printf('&a+1=%d/n',&a+1)//1020 加了20个字节，因为&a指向的是整个数组，整个数组做单位，所以是加了20个字节
```

访问数组元素：

- 下标法

- 指针法

```
int a[5]=[1,2,3,4,5];
int *p =a;//保存了a[0]

for(int i=0;i<5;i++){
    printf('%d',*(p+i))//打印出各个元素的值
  //  printf('%d',*p++)//或者采取这种，因为上面p+i，+是双目运算符，优先级比*低，所以需要括号，下面因为++的优先级高于*，所以不需要括号
}

//当然我们也可以拿数组名
for(int i=0;i<5;i++){

    printf('%d',*(a+i))//但是用数组名，只能用a+i的方式，因为数组名的地址不能变，a++的话，会改变a的地址，不可取
}
```

## 二维数组与指针 

```c++

int a[3][4]//这个数组虽然是三行四列，但是在内存存储空间里依旧是一块连续的空间

//a是一个二维数组，数组名a是这个二维数组的首地址，也就是说a指向的是二维数组的第一个存储单元，也就是a[0]这个一维数组,a的类型是 int(*)[4]类型，所以a+1会右移 4*4=16个字节

//那a[0]是这个一维数组的数组名，那么a[0]就是一维数组的首地址，根据首地址的定义，指向的是第一个存储单远，所以a[0]指向的是a[0][0]，所以a[0]的数据类型是 int*, a[0]+1 = a[0]+4

//所以三维数组一次类推

//那按照上面写的，我们可以得到
int main(){
int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
printf('a=%d\n',a)//是数组名a表示的是，这个二维数组的首地址，指向的是第一存储单元a[0]，类型是int(*)[4]
printf('a[0]=%d\n',a[0])//a[0]是一个一维数组的数组名，他是一个一维数组，首地址是第一个元素，然后指向的是第一个元素，类型是int *,也是指针常量类型，存储的是地址
printf(printf('&a[0]=%d\n',&a[0]))
printf('&a[0][0]=%d\n',&a[0][0])

//上面四个的答案都是一样的
    return 0;
}
``` 
汇总:
```
int a[3][4];

a        int(*)[4]
&a       int(*)[3][4]
a[0]     int*
&a[0]    int(*)[4]
a[0][0]  int 
```

### 多维数组访问元素

- 下标法：`a[m][n]`
- 指针法 `*(a[m]+n) a[m]=*(a+m) 所以 a[m][n]=*(*(a+m)+n)`
