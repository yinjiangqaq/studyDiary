## 实现函数节流

原理：每隔一段事件触发函数执行

### 时间戳实现

```js
function throttle(func, delay) {
  let prev = new Date();
  return function () {
    let context = this;
    let args = arguments;
    let now = new Date();
    if (now - prev >= delay) {
      func.apply(context, arguments);
      prev = new Date();
    }
  };
}
```

### 定时器实现

```js
function throttle(func, delay) {
  var timer = null;
  return function () {
    var context = this;
    var args = arguments;
    if (!timer) {
      timer = setTimeout(function () {
        func.apply(context, args);
        timer = null;
      }, delay);
    }
  };
}
```

## promise 和 generator 和 async 的区别

https://juejin.im/post/6844904159582355470

## this.router.push 的优缺点

不能跳转同路由，会报错
针对如何刷新当前的页面,我们有两种方法

当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。
因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。
不过，这也意味着组件的生命周期钩子不会再被调用。
复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) `$route` 对象：

```js
const User = {
  template: '...',
  watch: {
    '$route' (to, from) {
      // 对路由变化作出响应...
    }
  }
}
或者使用 2.2 中引入的 beforeRouteUpdate 导航守卫：

const User = {
  template: '...',
  beforeRouteUpdate (to, from, next) {
    // react to route changes...
    // don't forget to call next()
  }
}

```

如何是刷新当前页面的话可使用先 push 到一个空页再 push 回来，但是这个方案回导致一个空白效果，常用的是再 app.vue 定义一个 reload 方法，再子页面中调用

```js
//主要利用的是父子组件的provide和inject
// app.vue
<template>
    <router-view v-if="isRouterAlive"></router-view>
</template>

<script>
export default {
  name: "App",
  provide() {
    return {
      routerReload: this.reload
    };
  },
  data() {
    return {
      isRouterAlive: true
    };
  },
  methods: {
    reload() {
      this.isRouterAlive = false;
      this.$nextTick(() => (this.isRouterAlive = true));
    }
  }
};
</script>

// 需要的页面
export default {
  inject: ["routerReload"],
   methods: {
      reload(){
         this.routerReload()
      }
   }
}
```


## 装饰器

装饰器简单点说就是对一个函数自定义一些操作，也就是函数的返回值也是函数，利用到闭包

使用 JS 实现一个 `repeat` 方法，

function repeat (func, times, wait) {}
const repeatFunc = repeat(alert, 4, 3000),
调用这个 repeatedFunc("hellworld")，会 alert4 次 helloworld, 每次间隔 3 秒

需要注意的是，这里是函数调用一次，就已经会执行四次 alert，然后间隔三秒，所以需要用到 setInterval 的定时器，类似轮询一样，但是执行次数满了之后，需要销毁定时器

```js
function repeat(func, times, wait) {
  let timer = null;
  let context = this;
  //let args=arguments
  let count = 0;
  return function () {
    if (!timer) {
      timer = setInterval(function () {
        func.apply(context, arguments);
      }, wait);
      if (count === times) {
        clearInterval(timer);
      }
      count++;
    }
  };
}
```

## vue 中为什么需要有 this.\$set 这个方法的

首先我们知道 vue 中是通过 Object.definePropery()这个方法给 data 对象中的每个属性增加 set，get 监听的。如果只是单纯的简单属性

```js
data(){
    return{
        a:1//这种类型的
    }
}
```

这种简单类型的响应式监听的确能起到响应式效果，但是如果是复杂对象，或者数组

```js
data(){
    return{
        a:1//这种类型的
        b:{
            a:{
                c:1
            }
        }
    }
}
```

在这时候，需要 `this.$set(target,key,value)`

- target:需要更改的数据源(可以是对象或者是数组)
- 需要更新的具体数据的键值
- 重新赋的新值

## webpack 的打包

## vue 前端打包之后的 dist 的 js 文件有哪几种

## vue 中的 loader 怎么实现按需加载，以此实现减少首屏加载时间
https://router.vuejs.org/zh/guide/advanced/lazy-loading.html
