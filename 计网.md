## IP 组播

它通过使用特定的 IP 组播地址，按照最大投递的原则，将 IP 数据包传输到一个组播群组（multicast 　 group）的主机集合。它的基本方法是：当某一个人向一组人发送数据时，它不必将数据向每一个人都发送数据，只需**将数据发送到一个特定的预约的组地址**，**所有加入该组的人**均可以收到这份数据。这样对发送者而言，数据只需发送一次就可以发送到所有接收者，**大大减轻了网络的负载和发送者的负担**。

### 优点

- 组播可以增强报文发送效率，控制网络流量，减少服务器和 CPU 负载；
- 组播可以优化网络性能，消除流量冗余；
- 组播可以适应分布式应用，当接收者数量发生变化时，网络流量的波动很平稳。

## TCP 的三次握手

第一次握手：客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND 状态，等待服务器确认；
第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；
第三次握手：客户端收到服务器的 SYN ＋ ACK 包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）

![assets/imgs/tcp3.jpg](assets/imgs/tcp3.jpg)

https://www.cnblogs.com/bj-mr-li/p/11106390.html

### TCP 三次握手状态机

![assets/imgs/state.jpg](assets/imgs/state.jpg)
（1）CLOSED 状态时初始状态。

（2）LISTEN:被动打开，服务器端的 状态变为 LISTEN(监听)。被动打开的概念：连接的一端的应用程序通知操作系统，希望建立一个传入的连接。这时候操作系统为连接的这一端建立一个连 接。与之对应的是主动连接：应用程序通过主动打开请求来告诉操作系统建立一个连接。

（3）SYNRECVD:服务器端收到 SYN 后，状态为 SYN；发送 SYN ACK;

（4）SYN_SENTY:应用程序发送 SYN 后，状态为 SYN_SENT；

（5）ESTABLISHED:SYNRECVD 收到 ACK 后，状态为 ESTABLISHED； SYN_SENT 在收到 SYN ACK，发送 ACK，状态为 ESTABLISHED；

（6）CLOSE_WAIT:服务器端在收到 FIN 后，发送 ACK，状态为 CLOSE_WAIT；如果此时服务器端还有数据需要发送，那么就发送，直到数据发送完毕；此时，服务器端发送 FIN，状态变为 LAST_ACK;

（7）FIN_WAIT_1：应用程序端发送 FIN，准备断开 TCP 连接；状态从 ESTABLISHED——>FIN_WAIT_1；

（8）FIN_WAIT_2：应用程序端只收到服务器端得 ACK 信号，并没有收到 FIN 信号；说明服务器端还有数据传输，那么此时为半连接；

（9）TIME_WAIT:有两种方式进入 该状态：1、FIN_WAIT_1 进入：此时应用程序端口收到 FIN+ACK（而不是像 FIN_WAIT_2 那样只收到 ACK，说明数据已经发送完毕）并 向服务器端口发送 ACK；2、FIN_WAIT_2 进入：此时应用程序端口收到了 FIN，然后向服务器端发送 ACK；TIME_WAIT 是为了实现 TCP 全双工连接的可靠性关闭，用来重发可能丢失的 ACK 报文；需要持续 2 个 MSL(最大报文生存时间)：假设应用程序端口在进入 TIME_WAIT 后，2 个 MSL 时间内并没有收到 FIN,说明应用程序最后发出的 ACK 已经收到了；否则，会在 2 个 MSL 内在此收到 ACK 报文；

4.1.客户端应用程序的状态迁移图
客户端的状态可以用如下的流程来表示：
CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED
以上流程是在程序正常的情况下应该有的流程，从书中的图中可以看到，在建立连接时，当客户端收到 SYN 报文的 ACK 以后，客户端就打开了数据交互地连接。而结束连接则通常是客户端主动结束的，客户端结束应用程序以后，需要经历 FIN_WAIT_1，FIN_WAIT_2 等状态，这些状态的迁移就是前面提到的结束连接的四次握手。

4.2.服务器的状态迁移图
服务器的状态可以用如下的流程来表示：
CLOSED->LISTEN->SYN 收到->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSED
在建立连接的时候，服务器端是在第三次握手之后才进入数据交互状态，而关闭连接则是在关闭连接的第二次握手以后（注意不是第四次）。而关闭以后还要等待客户端给出最后的 ACK 包才能进入初始的状态。

4.3.其他状态迁移
书中的图还有一些其他的状态迁移，这些状态迁移针对服务器和客户端两方面的总结如下
LISTEN->SYN*SENT，对于这个解释就很简单了，服务器有时候也要打开连接的嘛。
SYN_SENT->SYN 收到，服务器和客户端在 SYN_SENT 状态下如果收到 SYN 数据报，则都需要发送 SYN 的 ACK 数据报并把自己的状态调整到 SYN 收到状态，准备进入 ESTABLISHED
SYN_SENT->CLOSED，在发送超时的情况下，会返回到 CLOSED 状态。
SYN*收到->LISTEN，如果受到 RST 包，会返回到 LISTEN 状态。
SYN\_收到->FIN_WAIT_1，这个迁移是说，可以不用到 ESTABLISHED 状态，而可以直接跳转到 FIN_WAIT_1 状态并等待关闭。

4.4.2MSL 等待状态
书中给的图里面，有一个 TIME_WAIT 等待状态，这个状态又叫做 2MSL 状态，说的是在 TIME_WAIT2 发送了最后一个 ACK 数据报以后，要进入 TIME_WAIT 状态，这个状态是防止最后一次握手的数据报没有传送到对方那里而准备的（注意这不是四次握手，这是第四次握手的保险状态）。这个状态在很大程度上保证了双方都可以正常结束，但是，问题也来了。

由于插口的 2MSL 状态（插口是 IP 和端口对的意思，socket），使得应用程序在 2MSL 时间内是无法再次使用同一个插口的，对于客户程序还好一些，但是对于服务程序，例如 httpd，它总是要使用同一个端口来进行服务，而在 2MSL 时间内，启动 httpd 就会出现错误（插口被使用）。为了避免这个错误，服务器给出了一个平静时间的概念，这是说在 2MSL 时间内，虽然可以重新启动服务器，但是这个服务器还是要平静的等待 2MSL 时间的过去才能进行下一次连接。

4.5.FIN_WAIT_2 状态
这就是著名的半关闭的状态了，这是在关闭连接时，客户端和服务器两次握手之后的状态。在这个状态下，应用程序还有接受数据的能力，但是已经无法发送数据，但是也有一种可能是，客户端一直处于 FIN_WAIT_2 状态，而服务器则一直处于 WAIT_CLOSE 状态，而直到应用层来决定关闭这个状态。
5.RST，同时打开和同时关闭
RST 是另一种关闭连接的方式，应用程序应该可以判断 RST 包的真实性，即是否为异常中止。而同时打开和同时关闭则是两种特殊的 TCP 状态，发生的概率很小。

## TCP 的四次挥手

## Socket 通信

**网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个 socket**，建立网络通信连接至少要一对端口号(socket)。socket 本质是编程接口 API，对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。

socket 利用客户/服务器模式巧妙地解决了进程之间建立通信连接的问题。服务器 socket 半相关为全局所公认非常重要。读者不妨考虑一下，两个完全随机的用户进程之间如何建立通信？假如通信双方没有任何一方的 socket 固定，就好比打电话的双方彼此不知道对方的电话号码，要通话是不可能的。

## 进程间通信的方式

socket 通信方式是进程通信的一种,先列举一下进程通信的种类:1）管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的 亲缘关系通常是指父子进程关系。2）有名管道（FIFO）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进 先出的通信方式。3）信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程 正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手 段。4）消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息 少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。5）信号 ( sinal ) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。6）共享内存( shared memory) 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制 如信号量，配合使用，来实现进程间的同步和通信。7）套接字( socket ) ：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程 通信。

## 利用 Socket 建立网络连接的步骤

建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一个运行于服务器端，称为 ServerSocket 。
套接字之间的连接过程分为三个步骤：**服务器监听，客户端请求，连接确认。**

1。服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。

2。客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

3。连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

## HTTP 和 HTTPS 的区别

https://juejin.im/entry/6844903471565504526
HTTPS 的原理

HTTPS 中 TSL 握手的过程

1. 客户端发送一个随机值，需要的协议和加密方式
2. 服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）
3. 客户端收到服务端的证书并验证是否有效，**验证通过会再生成一个随机值**，通过**服务端证书的公钥去加密这个随机值**并发送给服务端，如果服务端需要验证客户端证书的话会附带证书
4. 服务端收到加密过的随机值并使用**私钥解密获得第三个随机值**，这时候**两端都拥有了三个随机值**，可以通过这三个随机值按照之前**约定的加密方式**生成密钥，接下来的通信就可以通过该密钥来加密解密
   通过以上步骤可知，在 TLS 握手阶段，两端使用**非对称加密的方式来通信**，但是因为**非对称加密损耗的性能比对称加密大**，所以在正式传输数据时，两端使用对称加密的方式通信。

PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。

## HTTP 的 content-length

HTTP 头部 Content-Length 用于描述 HTTP 消息实体的传输长度，**浏览器对比 Content-Length 和 HTTP 请求或者响应 body 长度判断一次 HTTP 传输过程**，以独立于 TCP 长连接。

### HTTP 首部 Content-Length 使用场景

当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过 Content-length 消息首部字段告诉客户端需要接收多少数据。
HTTP 首部定义 Connection: keep-alive 后，客户端、服务端怎么知道本次传输结束呢？静态页面通过` Content-Length` 提前告知对方数据传输大小。

就是原本的 HTTP1.0 是 TCP 连接只用一次 HTTP 连接，传输完就会断开，后续为了提升性能，引入了长连接，首部定义 `Connection: keep-alive`,减少了建立连接所需要的时间

## 子网掩码

子网掩码是用来判断任意两台主机的 IP 地址是否属于同一网络的依据，就是拿双方主机的 IP 地址和自己主机的子网掩码做**与运算**，如结果为同一网络，就可以直接通信。IP 地址和子网掩码做与运算，把 IP 地址的主机位直接归 0，就快速得到网络地址。

## TCP 的队头阻塞

HTTP 队头阻塞的现象是由 HTTP1.1，keep-alive 的传输管道化导致的，因为传输是串行的，我们必须等待上一个请求结束才能到达下一个请求，如果上一个请求发生了丢包，或者其他原因，就会导致整个队列阻塞住了。等到丢的包重传，才会重新让整个队列动起来。

## http 响应报文，如果响应的内容比较大，客户端怎么样判断接收完了呢？

1. http 协议有正文大小说明的 content-length
2. 或者分块传输 chunked 的话(`Transfer-Encoding: chunked`) 读到 0\r\n\r\n 就是读完了

http 响应内容比较大的话，会分成多个 tcp segment 发送，不是最后一个 segment 的话， tcp 的 payload 不会有 http header 字段，

如果是最后一个 tcp segment 的话，就会有 http header 字段，同时， 数据的最后会有 "0\r\n\r\n" 这个东西，这个东西就表示数据都发送完了。

## 清除 ARP 缓存

命令行 arp-d

## http2.0 的多路复用怎么保证传输的有序性

http2 的传输是基于**二进制帧**的。每一个 TCP 连接中承载了多个双向流通的**流**，每一个流都有一个独一无二的**标识和优先级**，而流就是由二进制帧组成的。二进制帧的头部信息会标识自己属于哪一个流，所以这些帧(是由头部帧和数据帧组成)是可以交错传输，然后在接收端通过**帧头的信息**组装成完整的数据。这样就解决了线头阻塞的问题，同时也提高了网络速度的利用率。
。

在 TCP 协议中，数据的传输单位是数据报。数据分成两大部分。头部(header) 和 实际数据部分(body)。
在 HTTP 2.0 中，它把数据报的两大部分分成了 header frame 和 data frame。也就是头部帧和数据体帧。帧的传输最终在流中进行，流中的帧，头部(header)帧 和 data 帧可以分为多个片段帧，例如 data 帧即是可以 data = data_1 + data_2 + ... + data_n。

其次是**流**

- 双向性：同一个流内，可**同时发送和接受**数据。
- 有序性：流中被传输的数据就是二进制帧 。帧在流上的被发送与被接收都是按照顺序进行的。
- 并行性：流中的 二进制帧 都是被并行传输的，无需按顺序等待。但却不会引起数据混乱，因为每个帧都有**顺序标号**。它们最终会被按照顺序标号来合并。
- 流的创建：流可以被**客户端或服务器**单方面建立, 使用或共享。
- 流的关闭：流也可以被**任意一方关闭**。

## HTTP2.0 是采用二进制传输，为什么底层的 TCP 面向字节流的还是可以用

## TCP 的拥塞控制

### TCP 拥塞控制的一般原理

、产生拥塞的原因：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。即对资源的需求 > 可用资源

拥塞控制和流量控制的区别：

拥塞控制是防止过多的数据注入网络中，使得网络中路由器或链路**不致过载**。但有一个前提是，网络能够承受现有的网络负荷，是一个**全局性**的过程，流量控制是指点对点通信的控制，做的是**抑制发送端发送数据的速率，便于接收端来得及接收**

拥塞控制是一个动态的过程，通常使用网络负载（单位时间输入给网络的分组数量）和吞吐量（单位时间从网络输出的分组的数量）来进行比较：
当网络负载 >吞吐量，网络进入拥塞，严重甚至会产生死锁。

### TCP 拥塞控制的方法

1. 慢启动和拥塞避免

   基于窗口的拥塞控制，在发送方维护一个**拥塞窗口（cwnd），大小等于发送窗口**，通过出现了超时来判断网络出现拥塞慢开始的思路是一开始发送方发送一个字节，在收到接收方的确认，然后发送的字节数量增大一倍（也就是按照**指数增长**的速率），从小到大逐步**增大 cwnd**，**直到 cwnd 达到慢开始门限（ssthresh）**，**停止**慢开始算法，使用拥塞避免算法，拥塞避免算法思路是**增长速率变为线性增长**，也就是**每经过一个往返时间 RTT 就把发送方的 cwnd 加 1**，所以综上：

   当 cwnd < ssthresh ，使用慢开始算法；

   当 cwnd = ssthresh，可以使用慢开始算法，也可以使用拥塞算法；

   当 cwnd > ssthresh，使用拥塞算法；

2. 快重传(丢包,发送方接连收到三个相同的 ACK)和快恢复(超时)

通过上面两个算法可以使得网络传输速率一直增大，直到出现**超时**，这时候需要将 cwnd 重新调整到 1 个字节开始，使用慢开始算法，同时需要将慢开始门限 `ssthresh` 调整为 **cwnd（超时点）的一半**，继续执行慢开始、拥塞避免算法。如果收到 3-ACK（发送方一连接收到 3 个对同一个报文段的重复确认），这种可能的情况是，并不是发生了拥塞，可能是报文丢失，所以发送方不执行慢开始算法，直接使用快重传算法，立即发送缺失的报文段。同时执行快恢复算法，将门限值（ssthresh）调整为此时 cwnd 的一半，并执行拥塞避免算法。

## rdt2.0 产生位错误 bit error 的信道(只有该因素)

底层信道可能产生位错误

问题：接收方要知道分组错没错？如果错了得想办法重传？或者恢复

解决办法：检测位错误(差错检测)，从错误中恢复(ACK 确认机制接收方显式告诉发送方已正确接收的，NAK 接收方显式告诉发送方分组有错误。发送方收到 NAK 之后**重传**分组)

rdt2.0 引入的新机制：差错检测，接收方反馈控制信息，重传

### rdt2.1

发现 rdt2.0 的缺陷：当 ACK 或者 NAK 出错发送方是无法处理的，

因此加入新的机制，那就是序列号机制。

### rdt2.2

将 NAK 去掉（不需要），用**ACK 确认最后的一个分组**，可以代替它
