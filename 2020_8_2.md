## leetcode 面试题 04.02. 最小高度树
给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。

给定有序数组:` [-10,-3,0,5,9],`

一个可能的答案是：`[0,-3,9,-10,null,5]`，它可以表示下面这个高度平衡二叉搜索树：

解题思路：构造二叉搜索树(根大于左节点，小于右节点)，通过二分法查找根节点，然后递归左右节点
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function (nums) {
    if (nums.length <= 0) return null
    let m = Math.floor((nums.length - 1) / 2)
    let root = new TreeNode(nums[m])
    root.left = sortedArrayToBST(nums.slice(0, m));
    root.right = sortedArrayToBST(nums.slice(m + 1))
    return root
};
```

## 两数之和
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

给定 `nums = [2, 7, 11, 15], target = 9`

因为 `nums[0] + nums[1] = 2 + 7 = 9`
所以返回` [0, 1]`

解题思路：让时间复杂度从两次方到一次方，通过时空置换，空间置换时间，创造一个arr数组，存储每次遍历完的值的下标，等到`target-nums[i]`的差值，在arr中被找到时，返回两者的下标

```
var twoSum=function(nums,target){
    let arr = [];
    for (var i = 0; i < nums.length; i++) {
      let diff =target-nums[i]
      if(arr[diff]!==undefined){
          return [arr[diff],i]
      }else{
          arr[nums[i]]=i
      }
    }
```

## 反转链表
定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
`
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL`

```
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
    var reverse;
    var pre = null
    if (!head) return head
    while (head) {
        let pNext = head.next
        head.next = pre
        reverse = head
        pre = reverse
        head = pNext
    }
    return reverse
};
```
## 手动实现一个new
function myNew() {
    let obj = new Object()//新建一个对象
    let constructor = [...arguments].shift()
    obj.__proto__ = constructor.prototype//链接到原型
    let result = constructor.apply(obj, [...arguments].slice(1))//执行构造函数，绑定this
    return typeof result === 'object' ? result : obj//返回这个对象
}

## 实现一个深拷贝
主要是递归的方式来实现，利用判断每个属性是否是对象，再对对象进行深一层的拷贝

有个简单版的深拷贝实现，`利用JSON.parse(JSON.stringify(obj))`,来实现深拷贝，但是这种方法有缺点：

* 不能序列化函数
* 不能序列化循环引用的对象
* 会忽略undefined
* 会忽略symbol
```
function deepClone(item) {
    let target = item.constructor === Array ? [] : {}//判断复制的目标时对象还是数组
    if (item.constructor === Array) {
        target = Array.prototype.slice.call(item)//复制数组
    }
    for (let keys in item) {
        if (item.hasOwnProperty(keys)) {
            if (item[keys] && typeof item[keys] === 'object') {
                target[keys] = deepClone(item.keys)
            } else {
                target[keys] = item[keys]
            }
        }
    }
    return target
}
```