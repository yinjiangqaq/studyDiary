## 爱生气的书店老板

今天，书店老板有一家店打算试营业  customers.length  分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。

在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。

书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续  X 分钟不生气，但却只能使用一次。

请你返回这一天营业下来，最多有多少客户能够感到满意的数量。

```
输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3
输出：16
解释：
书店老板在最后 3 分钟保持冷静。
感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.

```

自己的解法：

```js
/**
 * @param {number[]} customers
 * @param {number[]} grumpy
 * @param {number} X
 * @return {number}
 */
var maxSatisfied = function (customers, grumpy, X) {
  var res = 0;
  for (let i = 0; i <= grumpy.length - X; i++) {
    let temp = customers.slice(i, i + X).reduce((x, y) => x + y, 0);
    let rest = 0;
    for (let j = 0; j < customers.length; j++) {
      if (j >= i && j < i + X) {
        continue;
      } else {
        if (grumpy[j] === 0) {
          rest += customers[j];
        }
      }
    }
    res = Math.max(res, rest + temp);
  }
  return res;
};
```

官方的，也就是，不做两次 for 循环，降低时间复杂度

```js
var maxSatisfied = function (customers, grumpy, X) {
  let total = 0;
  const n = customers.length;
  for (let i = 0; i < n; i++) {
    if (grumpy[i] === 0) {
      total += customers[i];
    }
  }
  let increase = 0;
  for (let i = 0; i < X; i++) {
    increase += customers[i] * grumpy[i];
  }
  let maxIncrease = increase;
  for (let i = X; i < n; i++) {
    increase =
      increase - customers[i - X] * grumpy[i - X] + customers[i] * grumpy[i];
    maxIncrease = Math.max(maxIncrease, increase);
  }
  return total + maxIncrease;
};
```

## dom.children 和 childrenNode

对于 Dom 元素。children 是指 DOM object 类型的子对象，不包括 tag 之间隐形存在的 textNode

而 childNode 包括 tag 之间隐形存在的 textNode

## 翻转图像

给定一个二进制矩阵  A，我们想先水平翻转图像，然后反转图像并返回结果。

水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转  [1, 1, 0]  的结果是  [0, 1, 1]。

反转图片的意思是图片中的  0  全部被  1  替换， 1  全部被  0  替换。例如，反转  [0, 1, 1]  的结果是  [1, 0, 0]。

```
输入：[[1,1,0],[1,0,1],[0,0,0]]
输出：[[1,0,0],[0,1,0],[1,1,1]]
解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/flipping-an-image
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

```js
var flipAndInvertImage = function (A) {
  const n = A.length;
  const m = A[0].length;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m / 2; j++) {
      //颠倒，外加反转，也就是异或^,因为这个是二进制数
      [A[i][j], A[i][m - 1 - j]] = [1 ^ A[i][m - 1 - j], 1 ^ A[i][j]];
    }
  }
  return A;
};
```

## 对象里面自带的 delete 操作

```js
let obj = {
  A: 1,
  B: 2,
};

delete obj.B;
//删除掉对象的B属性
```

## 二叉树的堂兄弟节点

在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。

如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。

我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。

只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/cousins-in-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```
输入：root = [1,2,3,4], x = 4, y = 3
输出：false

输入：root = [1,2,3,null,4,null,5], x = 5, y = 4
输出：true
```

解题思路：根据题目所讲，我们需要知道的只有两个信息量，一个是节点的深度，一个是节点的父节点。而我们在对树进行深度遍历 dfs 的时候，可以把这两个作为参数，传给下一次递归。所以用一次深度遍历，便可以解决问题

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
var isCousins = function (root, x, y) {
  let depth_x = 0;
  let depth_y = 0;
  let father_x = null;
  let father_y = null;
  let found_x = false;
  let found_y = false;
  var dfs = (node, depth, parent) => {
    if (!node) {
      return;
    }
    if (node.val === x) {
      [depth_x, father_x, found_x] = [depth, parent, true];
    } else if (node.val === y) {
      [depth_y, father_y, found_y] = [depth, parent, true];
    }
    if (found_x && found_y) return;
    dfs(node.left, depth + 1, node);
    if (found_x && found_y) return;
    dfs(node.right, depth + 1, node);
  };
  dfs(root, 0, null);
  if (depth_x === depth_y && father_x.val !== father_y.val) {
    return true;
  } else {
    return false;
  }
};
```

## 1442. 形成两个异或相等数组的三元组数目

给你一个整数数组 arr 。

现需要从数组中取三个下标 i、j 和 k ，其中 (0 <= i < j <= k < arr.length) 。

a 和 b 定义如下：

a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
注意：^ 表示 按位异或 操作。

请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```
输入：arr = [2,3,1,6,7]
输出：4
解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)

输入：arr = [1,1,1,1,1]
输出：10
```

```
解题思路：
Si=arr[0]^arr[1]^...^arr[i-1]
Sj= arr[0]^arr[1]^...^arr[i-1]^arr[i]^...^arr[j-1]
//根据异或本身等于零，推出
a => Si^Sj

b=>Sj^Sk+1

a=b =>  Si^Sj=Sj^Sk+1 =>Si=Sk+1
```

```js
/**
 * @param {number[]} arr
 * @return {number}
 */
var countTriplets = function (arr) {
  //根据推算可以推算出 Si= Sk+1
  let res = [0];
  for (let num of arr) {
    res.push(res[res.length - 1] ^ num); //算出每个Si
  }
  let n = arr.length;
  let ans = 0;
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      for (k = j; k < n; k++) {
        if (res[i] === res[k + 1]) ans++;
      }
    }
  }
  return ans;
};
```
