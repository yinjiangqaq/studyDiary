## http 强缓存和协商缓存

https://juejin.im/post/6847902216200650760

- 相同点：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据
- 不同点： 强缓存不发请求到服务器，协商缓存会发请求到服务器

## 基本原理

- .浏览器在加载资源时，根据请求头的 expires 和 cache-control 判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器`200 from cache`
- 如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过 last-modified 和 etag 验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源 `返回403`
- 如果前面两者都没有命中，直接从服务器加载资源 `返回200`

## map 和 forEach 的区别

map 函数有返回值，forEach 函数没有，而且 map 返回其原始数组的新数组，但是它们都确保了原始对象的不变性

```js
[1, 2, 3].map((d) => d + 1); // [2, 3, 4];
[1, 2, 3].forEach((d) => d + 1); // undefined;
```

如果更改数组内的值，forEach 不能确保数组的不变性。这个方法只有在你不接触里面的任何值时，才能保证不变性。

```js
[
  { a: 1, b: 2 },
  { a: 10, b: 20 },
].forEach((obj) => (obj.a += 1));
// [{a: 2, b: 2}, {a: 11, b: 21}]
// 数组已更改！这里obj.a+=1相当于给他重新赋值了,而且每个元素还是个对象
```

## jsonp 实现跨域时服务器端怎么处理数据

前端 jsonp 发跨域请求配置

```html
<%@ page pageEncoding="utf-8" contentType="text/html;charset=UTF-8"
language="java" %>
<html>
  <head>
    <title>跨域测试</title>
    <script src="js/jquery-1.7.2.js"></script>
    <script>
      //回调函数
      function showData(result) {
        var data = JSON.stringify(result); //json对象转成字符串
        $("#text").val(data);
      }

      $(document).ready(function () {
        $("#btn").click(function () {
          //向头部输入一个脚本，该脚本发起一个跨域请求
          $("head").append(
            "<script src='http://localhost:9090/student?callback=showData'><\/script>"
          );
        });
      });
    </script>
  </head>
  <body>
    <input id="btn" type="button" value="跨域获取数据" />
    <textarea id="text" style="width: 400px; height: 100px;"></textarea>
  </body>
</html>
```

当点击"跨域获取数据"的按钮时，添加一个`<script>`标签，用于发起跨域请求；注意看请求地址后面带了一个 callback=showData 的参数；

showData 即是回调函数名称，传到后台，用于包裹数据。数据返回到前端后，就是 showData(result)的形式，因为是 script 脚本，所以自动调用 showData 函数，而 result 就是 showData 的参数。

至此，我们算是跨域把数据请求回来了，但是比较麻烦，需要自己写脚本发起请求，然后写个回调函数处理数据，不是很方便。

服务端做的对数据的处理

```java
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setCharacterEncoding("UTF-8");
    response.setContentType("text/html;charset=UTF-8");

    //数据
    List<Student> studentList = getStudentList();


    JSONArray jsonArray = JSONArray.fromObject(studentList);
    String result = jsonArray.toString();

    //前端传过来的回调函数名称,
    //拿到query参数

    String callback = request.getParameter("callback");
    //用回调函数名称包裹返回数据，这样，返回数据就作为回调函数的参数传回去了
    //result其实是一个json字符串，然后前端执行对应的回调之后会进行序列化就行了
    result = callback + "(" + result + ")";

    response.getWriter().write(result);
}
```

## https://blog.csdn.net/weixin_42098339/article/details/102830381

## css 的怪异盒与标准盒，他们是怎样切换的

## js 的基本数据类型和引用类型有哪些，怎么判断

js 的基本数据类型:`Boolean, Number, String, null, undefined, symbol`

准确地说，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是**该对象在堆内存的地址**。
宽松来说，JavaScript 的引用数据类型只有对象

## 判断数组，数组去重

## js 动画和 CSS 动画的区别

## JavaScript 字符转成 ASCII 字符

```js
str.charCodeAt();

"A".charCodeAt() - 64 == 1;
```

将 ascii 码转为对应字母的方法：

```js
var num = 97;
String.fromCharCode(num); // 'a'

var num1 = 100;
String.fromCharCode(num1); // 'd'
```
