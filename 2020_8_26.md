## 作用域链

- 每个函数都有一个执行环境，执行环境关联一个变量对象，变量对象的集合叫做作用域链
- **作用域链的前端始终是当前执行环境所在的变量对象，下一个对象是外部函数，一直延续到全局变量**

* 标识符解析式沿着作用域链从前端逐级回溯的过程
* 代码执行完毕之后，所在的环境会被销毁，web 全局执行环境式 window 对象，全局对象会在应用程序退出的时候被销毁

## 闭包

闭包是指**有权访问另外一个函数作用域中的变量**的函数

用途：

- 读取另一个函数的内部的变量
- 让这些变量的值始终保存在内存中，不会因为 f 调用之后被自动清除
- 方便调用上下文的局部变量，利于代码封装

闭包的 this 指向的式它定义的地方的 this，非严格模式下，函数内部的 this 指向全局对象（严格模式下，this 为 undefined），函数 checkScope 的 this 指向的是 window 对象，所以返回了 window scope

```js
var scope = "window scope";
function checkScope() {
  var scope = "local scope";
  function f() {
    return this.scope;
  }
  return f;
}
checkScope()(); //=> "window scope"
```

### 闭包的应用场景

在经典面向对象的编程语言中，Constructor 是一种在内存已分配给该对象的情况下，用于初始化新创建对象的方法。
在 JavaScript 中，几乎所有的东西都是对象，我们通常最感兴趣的是 object 构造器。

Object 构造器用于构建特定类型的对象--准备好对象以备使用，同时接收构造器可以使用的参数，以在第一次创建对象时，设置成员属性和方法的值。

```js
// 构造器模式
function Car(model, year, miles) {
  this.model = model;
  this.year = year;
  this.miles = miles;

  Car.prototype.toString = function () {
    return this.model + "has done " + this.miles + " miles";
  };
}

var civic = new Car("honda civic", 2019, 2000);
console.log(civic.toString());
```

- javaScript 不支持类的概念，但支持与对象一起用的特殊 constructor（构造器）函数，通过在构造器前面加 new 关键字，告诉 JavaScript 像使用构造器一样实例化一个新对象，并且对象成员由该函数定义。
- toString 这样的函数在这里在每次创建新的实例的时候都被重新定义，这不是最理想的，toString 应该在所有的 Car 构造的实例之间共享。所以把 toString 放在 Car 的 prototype（原型对象）上，Car 构建的所有实例，都会访问同一个原型对象并获取到 toString 方法。
  这里 toString 就是一个闭包，function 可以访问实例中的 model，miles 和 year 变量。

### 闭包的风险

由于闭包会使得函数中的变量会被更长时间保存在内存中，消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中更是可能导致内存泄露。解决方法是，在**退出函数之前，将不使用的局部变量全部删除**。

## 内存泄漏

应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收，也就是内存没有被释放

### JavaScript 内存管理

JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。

### 垃圾回收算法（mark and sweep 标记清除）

- 垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；
- 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果**是可达的**，它就不被当作垃圾。
- 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。
  现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。

不需要的引用是指开发者明知内存引用不再需要，却由于某些原因，**它仍被留在激活的 root 树**中。在 JavaScript 中，不需要的引用是保留在代码中的变量，它不再需要，却指向一块本该被释放的内存。有些人认为这是开发者的错误。

为了理解 JavaScript 中最常见的内存泄漏，我们需要了解哪种方式的引用容易被遗忘。

### 三种类型常见 JavaScript 内存泄漏

- 意外的全局变量
  JavaScript 处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是`window`。

```js
function foo() {
  bar = "this is a hidden global variable";
}
```

然鹅实际上的真相是：

```js
function foo(arg) {
  window.bar = "this is an explicit global variable";
}
```

函数 foo 内部忘记使用 var ，意外创建了一个全局变量。此例泄漏了一个简单的字符串，无伤大雅，但是有更糟的情况。

另一种意外的全局变量可能由 this 创建：

```js
function foo() {
  this.variable = "potential accidental global";
}
//this 指向了全局对象window
```

> 在 JavaScript 文件头部加上 'use strict'，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。

- 被遗忘的计时器或者回调函数
  javascript 中的 setInterval

```js
var someRource = getData();
setInterval(function () {
  var node = document.getElementById("Node");
  if (node) {
    node.innerHTML = JSON.stringify(someResouce);
  }
});
```

此例说明了什么：与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，someResource 如果存储了大量的数据，也是无法被回收的。

对于观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。如今，即使没有明确移除它们，一旦观察者对象变成不可达，大部分浏览器是可以回收观察者处理函数的。

观察者代码实例：

```js
var element = document.getElementById("button");
element.addEventListener("click", (event) => {
  element.innerHTML = "text";
});
```

老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。如今，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法，已经可以正确检测和处理循环引用了。换言之，回收节点内存时，不必非要调用 `removeEventListener` 了。

## 代码回收的规则

1. 全局变量不会被回收
2. 局部变量会被回收，也就是函数一旦运行完以后，函数内部的东西就会被销毁
3. 只要被**另外一个作用域**所引用就不会被回收

- 闭包

```js
function A() {
  var arr = [1, 2];
  return function () {
    return arr;
  };
}
```

执行一次 A 函数之后，虽然 A 函数已经退出了调用栈，但是闭包函数还是一直存在于内存中的，因为它用到了 arr 变量的引用

### 拓展

https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/

http://www.ruanyifeng.com/blog/2017/04/memory-leak.html

## 代码题：逛街

小 Q 在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有 n 座高楼排成一行。

小 Q 从第一栋一直走到了最后一栋，小 Q 从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住）

输入描述：

> 输入第一行将包含一个数字 n，代表楼的栋数，接下来的一行将包含 n 个数字 wi(1<=i<=n)，代表每一栋楼的高度。
>
> 1<=n<=100000;
> 1<=wi<=100000;

输出描述:

> 输出一行，包含空格分割的 n 个数字 vi，分别代表小 Q 在第 i 栋楼时能看到的楼的数量。

示例：

输入：

> 6
>
> 5 3 8 3 2 5

输出：

> 3 3 5 4 4 4

说明

> 当小 Q 处于位置 3 时，他可以向前看到位置 2,1 处的楼，向后看到位置 4,6 处的楼，加上第 3 栋楼，共可看到 5 栋楼。当小 Q 处于位置 4 时，他可以向前看到位置 3 处的楼，向后看到位置 5,6 处的楼，加上第 4 栋楼，共可看到 4 栋楼。

```js
var left = function (arr) {
  if (arr.length < 2) return arr.length;
  let temp = arr[arr.length - 1];
  let num = 1;
  for (let i = arr.length - 2; i >= 0; i--) {
    if (arr[i] > temp) {
      num++;
      temp = arr[i];
    }
  }
  return num;
};
var right = function (arr) {
  if (arr.length < 2) return arr.length;
  let temp = arr[0];
  let num = 1;
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > temp) {
      num++;
      temp = arr[i];
    }
  }
  return num;
};

var n = parseInt(readline());
let temps = readline().split(" ");

let towns = temps.map((item) => {
  return parseInt(item);
});
let res = [];
for (let i = 0; i < towns.length; i++) {
  res.push(1 + right(towns.slice(i + 1)) + left(towns.slice(0, i)));
}
print(res.join(" "))(function () {})(i);
```

## 常见的浏览器及其内核

- IE trident
- firefox gecko
- chrome blink
- safari webkit
- opera webkit

## 详解 vue 数据的双向绑定

https://juejin.im/entry/6844903479044112391
