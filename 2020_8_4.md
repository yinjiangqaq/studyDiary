## JWT 的组成

jwt 是信息加密的一种方式，一个 JWT 由三个部分组成：`header，payload，signature`。分别保存了不同的信息。三个部分在 JWT 中分别对应英文句号分割出来的三个串：

### header

header 部分由以下的 json 结构生成：

```json
{
  "typ": "JWT",
  "alg": "HS256"
}
```

typ 用来标识整个 `token` 是一个 jwt 字符串，alg 代表签名和摘要算法，一般签发 JWT 的时候，只要 typ 和 alg 就够了，生成方式是将 `header` 部分的 `json` 字符串经过 `Base64Url` 编码：

### playload

`playload` 用来**承载要传递的数据**，它的一个属性对被称为 claim，这样的标准成为 claims 标准，同样是将其用 Base64Url 编码

```json
{
  "name": "john",
  "pwd": "123"
}
```

### signature

signature 部分是将前两个部分的 json 拼接中间加一点，再将这个拼接后的字符串用 alg 中的 hash 算法处理

```js
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret);
```

## 浏览器的进程和线程

### 进程

进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。我们这里将进程比喻为工厂的车间，它代表 CPU 所能处理的单个任务。任一时刻，**CPU 总是运行一个进程，其他进程处于非运行状态。**

### 线程

- 进程是操作系统分配资源的最小单位，线程是**程序执行的最小单位**。
- 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；
- **进程之间相互独立**，但同一进程下的**各个线程之间共享程序的内存空间**(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。
- 调度和切换：线程上下文切换比进程上下文切换要快得多。

### 多进程和多线程

- 多进程：多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。
- 多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。

### 那浏览器一个标签页是属于一个线程还是进程

对于 chrome 来说是每个标签页一个进程。在浏览器刚被设计出来的时候，那时的网页非常的简单，每个网页的资源占有率是非常低的，因此一个进程处理多个网页时可行的。然后在今天，大量网页变得日益复杂。**把所有网页都放进一个进程的浏览器面临在健壮性，响应速度，安全性方面的挑战**。因为如果**浏览器中的一个 tab 网页崩溃的话**，将会导致其他被打开的网页应用。另外相对于线程，进程之间是不共享资源和地址空间的,所以不会存在太多的安全问题，而由于多个线程共享着相同的地址空间和资源,所以会存在线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。

### 浏览器内核是多线程

简单来说浏览器内核是通过取得页面内容、整理信息（应用 CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。从上面我们可以知道，Chrome 浏览器为每个 tab 页面单独启用进程，因此**每个 tab 网页都有由其独立的渲染引擎实例**。

浏览器的多线程包括：

- GUI 渲染线程
- JavaScript 引擎线程
- 定时触发器线程
- 事件触发线程
- 异步 http 请求线程

其中 GUI 渲染线程 与 JavaScript 引擎线程互斥！

由于 **JavaScript 是可操纵 DOM 的**，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲**染线程前后获得的元素数据就可能不一致了**。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。所以**如果 JS 引擎执行时间过长，会导致页面卡顿**。

### 定时触发器线程

浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为**JavaScript 引擎是单线程**的, 如果**处于阻塞线程状态就会影响记计时的准确**, 因此通过单独线程来计时并触发定时是更为合理的方案。

### 事件触发线程

当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。

### 异步 HTTP 请求线程

在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。

## 浏览器的 macro 和 micro

对于单线程的 JavaScript 而言，如果所有的操作都是同步的，毫无疑问会造成浏览器的阻塞，对于及时响应处理用户点击等操作是不利的。因此在浏览器环境中需要引入异步的处理机制，也就是事件循环。

### 浏览器中事件循环

在讲浏览器中的事件循环之前，有必要先提一下 JavaScript 中的执行栈，执行栈可以理解为 JS 引擎当前正在执行的任务，只有将当前任务执行完，才会去检查当前事件队列中是否有任务，如果有，则压入执行栈中执行；否则继续检查事件队列中是否有新任务到来，以此循环往复，构成事件循环。一个典型的例子：

```js
setTimeout(() => {
  console.log("async");
}, 0);
let sum = 0;
for (let i = 0; i < 999999; i++) {
  sum++;
}
console.log("end");
```

JS 引擎在执行到 setTimeout 函数，因为延迟时间为 0，由定时触发器线程立即将回调函数放入到事件队列中，同时 JS 引擎继续向下执行当前执行栈中的任务，也就是一直到循环结束，打印出 end 之后，才会去检查事件队列中是否有任务，然后才将前面的定时器回调压入执行栈中执行。
也就是先执行同步代码，再执行异步代码

### js 任务

JS 引擎执行的任务可以分为两种，一种 `Macro Task`，另一种叫 `Micro Task`。当前正在执行的任务可能会衍生出新的 `Macro Task` 或者 `Micro Task`，然后会被放入**事件队列**中，等待 JS 引擎当前执行栈执行完成之后，再被放入到执行栈中执行。而衍生出来的所有的 `Micro Task` 会在执行下一个 `Macro Task` 之前被放入执行栈执行，也就是说在将一个 `Macro Task` 放入执行栈之前会将当前的`Micro Task 队列`清空。那么具体都有哪些 `Macro Task` 和 `Micro Task` 呢？

属于 `Macro Task` 的有 `setTimeout` 函数的回调、` DOM 事件处理函数``setInterval `, `setImmediate`,`I/O`,`UI` `rendering`。

属于 `Micro Task` 的有 `Promise` 对象的 `resolve` 或 `reject 回调`、`MutationObserver 对象的回调`。

举例：

```html
<div class="outer">
  <div class="inner"></div>
</div>
```

```js
var outer = document.querySelector(".outer");
var inner = document.querySelector(".inner");

new MutationObserver(function () {
  console.log("mutate");
}).observe(outer, {
  attributes: true,
});

function onClick() {
  console.log("click");

  setTimeout(function () {
    console.log("timeout");
  }, 0);

  Promise.resolve().then(function () {
    console.log("promise");
  });

  outer.setAttribute("data-random", Math.random());
}

inner.addEventListener("click", onClick);
outer.addEventListener("click", onClick);
```

在上面的例子中，当点击 inner 元素时，会将 inner 元素的点击事件处理函数放入到`Macro Task 事件队列`中，同时点击事件冒泡到父元素，进而触发父元素的点击事件，将同样的处理函数又放入到`Macro Task 事件队列`中一次。此时 JS 引擎是空闲的，因此会从 Macro Task 事件队列中取出一个任务，也就是第一次放入的事件处理函数会被压入执行栈中，在执行该处理函数时会再将 **setTimeout 函数回调放入到 Macro Task 事件队列** 中，接着又向 Micro Task 队列压入 Promise 对象的 resolve 回调和 MutationObserver 监听到元素属性发生变化的回调。

至此第一个 Macro Task 执行完毕，此时在取出第二个 Macro Task 也就是第二次被放入到 Macro Task 的父元素点击事件处理函数之前，JS 引擎会清空 Micro Task 队列中所有的 Task。也就是说，此时会打印出 promise 和 mutate。然后取出第二次被放入到 Macro Task 的父元素点击事件处理函数并压入执行栈，同样会产生新的 setTimeout Macro Task，接着清空 Micro Task 队列，同样打印出 promise 和 mutate。最后剩下的两个 setTimeout Macro Task 先后被压入执行栈，打印了两次 timeout。因此最终的打印结果：

```
click
promise
mutate
click
promise
mutate
timeout
timeout
```

## HTTP1.X 与 HTTP2.0

### HTTP 与 HTTP1.X 的区别

- 1.x 多了 keep-alive 长连接的设置
- 1.x 的 cache-control(时间段) 强缓存字段和 1.0 的 expires 字段(过期时间)

- 1.x 的 `ETag` 和 `if-None-Match` 协商字段(`ETag` 类似于文件指纹，`If-None-Match`会将当前 `ETag` 发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified`高) (`Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified`的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。) 和 1.0 的 `Last-Modified` 和 `if-Modified-Since` 协商字段

### HTTP1.x 和 HTTP2.0

HTTP 的新特性：

- 多路复用
- 二进制传输
- 服务端主动 push
- header 压缩

### 多路复用

1）HTTP2 的请求的 TCP 的 connection 一旦建立，后续请求以 stream 的方式发送。

2）每个 stream 的基本组成单位是 frame（二进制帧），每种 frame 又分为很多种类型例如 HEADERS Frame（头部帧），DATA Frame（内容帧）等等。

3）请求头 HEADERS Frame 组成了 resquest，返回头 HEADERS Frame 和 DATA Frame 组成了 response，request 和 response 组成了一个 stream。

### 多路复用和 keep-alive 区别

1）线头阻塞（Head-of-Line Blocking），HTTP1.X 虽然可以采用 keep alive 来解决复用 TCP 的问题，但是还是无法解决请求阻塞问题。

2）所谓请求阻塞意思就是一条 TCP 的 connection 在同一时间只能允许一个请求经过，这样假如后续请求想要复用这个链接就必须等到前一个完成才行，正如上图左边表示的。

3）之所以有这个问题就是因为 HTTP1.x 需要每条请求都是可是识别，按顺序发送，否则 server 就无法判断该相应哪个具体的请求。

4）HTTP2 采用多路复用是指，在同一个域名下，开启一个 TCP 的 connection，每个请求以 stream 的方式传输，每个 stream 有唯一标识，connection 一旦建立，后续的请求都可以复用这个 connection 并且可以同时发送，server 端可以根据 stream 的唯一标识来相应对应的请求。

## Vue

### vue v-if 和 v-show 的区别

相同点：两者都是条件渲染

不同点：

- v-if 在条件切换的时候，都会对标签进行适当的创建和销毁，而 v-show 则仅在初始化时候加载一次，因此 v-if 的开销会更大一些
- v-if 是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则 v-if 不会去渲染标签。v-show 则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的 CSS 切换

### watch 和 computed 的区别

- computed

1. 支持缓存，只有依赖数据发生改变，才会重新进行计算
2. 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化
3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值
4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed
5. 如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法。

- watch

1. 不支持缓存，数据变，直接会触发相应的操作；
2. watch 支持异步；
3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
4. 当一个属性发生变化时，需要执行对应的操作；一对多；
5. 监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数，

   immediate：组件加载立即触发回调函数执行，

   deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep 无法监听到数组的变动和对象的新增，参考 vue 数组变异,只有以响应式的方式触发才会被监听到。

## Vue.mixin( mixin )

接受的参数是一个 mixin 对象

用法：
全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用。

它会影响当前创造的 vue 实例，相当于很多类似公用的操作可以独立开，然后封装成一个 mixin，然后当需要的时候导入，不用在重复写逻辑

```js
// 为自定义的选项 'myOption' 注入一个处理器。
Vue.mixin({
  created: function () {
    var myOption = this.$options.myOption;
    if (myOption) {
      console.log(myOption);
    }
  },
});

new Vue({
  myOption: "hello!",
});
// => "hello!"
//另外一种方式
export default {
  name: "auth-user",
  mixins: [common],
  props: {},
};
//common
export default {
  data() {
    return {
      authCode,
      formData: {},
      appId: -1,
      appList: [],
      // 资源，rbac
      typeValue: "default",
      // codeDesc: 0,
      resourceTypeList: [],
      resourceList: [],
      rbacPlusLoading: false,
      resourceId: 0, // 资源id 废弃
      resourceCode: "",
    };
  },
  ...
};
```

## vue keep-alive

https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive

我们之前曾经在一个多标签的界面中使用 is attribute 来切换不同的组件：

```html
<component v-bind:is="currentTabComponent"></component>
```

当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。

重新创建**动态组件**的行为通常是非常有用的，但是在这个案例中，我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，我们可以用一个 `<keep-alive>`元素将其**动态组件**包裹起来。

```html
<!-- 失活的组件将会被缓存！-->
<keep-alive>
  <component v-bind:is="currentTabComponent"></component>
</keep-alive>
```

`<keep-alive>` 包裹动态组件时，**会缓存不活动的组件实例，而不是销毁它们**。和 `<transition>` 相似，`<keep-alive>` 是一个抽象组件：它**自身不会渲染一个 DOM 元素**，也不会出现在组件的父组件链中。

当组件在 `<keep-alive>` 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。

注意，`<keep-alive>` 是用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素，`<keep-alive>` 要求同时**只有一个子元素**被渲染。

```html
<!-- 基本 -->
<keep-alive>
  <component :is="view"></component>
</keep-alive>

<!-- 多个条件判断的子组件 -->
<keep-alive>
  <comp-a v-if="a > 1"></comp-a>
  <comp-b v-else></comp-b>
</keep-alive>

<!-- 和 `<transition>` 一起使用 -->
<transition>
  <keep-alive>
    <component :is="view"></component>
  </keep-alive>
</transition>
```
